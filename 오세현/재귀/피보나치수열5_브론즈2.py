"""
백준 10870번 피보나치 수 5_브론즈2

문제
피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.

이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.

n=17일때 까지 피보나치 수를 써보면 다음과 같다.

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597

n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다.

출력
첫째 줄에 n번째 피보나치 수를 출력한다.
"""

#반복문으로 풀어보기

n = int(input())

fibo = [0, 1]

for i in range(2, n+1):
    re = fibo[i-2] + fibo[i-1]
    fibo.append(re)

print(fibo[i])


#재귀 함수를 이용해서 풀어보기
"""
풀이과정:

재귀함수 강의 예제였던 1부터 n까지의 합을 구하는 코드에서는 숫자를 하향식으로 더했으나,
피보나치 수열은 앞의 두 수를 더해야 하므로 하향식이 불가능할 것 같아 상향식 접근을 시도함

우선 n이 0 또는 1일 경우: 자기 자신을 출력.

Base case: 재귀 함수 종료 부분
    -> 피보나치 수열 값을 저장한 리스트의 길이가 n과 같아질 경우: n번째 값을 반환 및 종료

Recursive case: 자기 자신 호출 부분
    -> 2번째일 경우, 0번째 1번째 값 더한 후 리스트에 append
        3번째일 경우, 1번째 2번째 ~~
        n번째일 경우, n-2번째 n-1번째 값 더해서 리스트에 저장
        recur(n) = recur(n-2) + recur(n-1)
"""

#재귀함수로 풀어보기
#처음 작성한 코드

def recur(n):

    fibo = [0, 1]   #피보나치 수열 값을 저장할 리스트

    if n == 0:
        return 0
    elif n == 1:
        return 1

    #Base Case: 재귀함수 종료 (피보나치 수열 리스트 원소 수가 n과 동일해지면)
    elif n == len(fibo):
        return fibo[n - 1]      #n번째 피보나치 수열 원소 반환

    else:
        i = 2
        re = fibo[i - 2] + fibo[i - 1]
        fibo.append(re)

        i += 1
        return recur(n - 2) + recur(n - 1)

n = int(input())
print(recur(n))

#결과값은 맞게 출력되는데, 재귀부분이 뭔가 조잡함...
#종료 조건도 잘못 생각함. n == len(fibo)를 종료 조건으로 잡으면, 재귀 함수를 사용하는 의미가 없음.

# 수정하여 제출한 코드

def recur(n):


    # n이 5든 15든, 결과적으론 recur(0)과 recur(1)의 합과 같으므로
    #Base Case: n의 값이 0 또는 1이면 값 반환 및 재귀 종료
    if n == 0:
        return 0
    elif n == 1:
        return 1
    #Recursive Case
    else:
        return recur(n - 2) + recur(n - 1)

n = int(input())
print(recur(n))

"""
느낀점:
재귀함수의 종료 부분을 떠올리는 게 어렵다.
그래도 코드를 간략하게 짤 수 있어 효율적인 것 같다.
앞으론 손으로 실행 과정 써보면서 최종 종료 조건을 생각해보자.
"""