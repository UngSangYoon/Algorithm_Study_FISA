'''
스도쿠 스페셜 저지

문제
스도쿠는 18세기 스위스 수학자가 만든 '라틴 사각형'이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 
이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데,
게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.

나머지 빈 칸을 채우는 방식은 다음과 같다.

각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.

또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.

이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.

게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.

입력
아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 
스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.

출력
모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.

스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.
'''

import sys  # 시스템 관련 기능을 사용하기 위해 sys 모듈을 가져옵니다.
input = sys.stdin.readline  # 빠른 입력 처리를 위해 input 함수를 sys.stdin.readline으로 대체합니다.

# 스도쿠 판 입력: 9줄에 걸쳐 각 줄에 9개의 숫자를 입력받아 9x9 2차원 리스트 board에 저장합니다.
board = [list(map(int, input().split())) for _ in range(9)]

# 각 행(row), 열(col), 그리고 3x3 정사각형(square)에서 사용된 숫자를 체크하기 위한 리스트를 초기화합니다.
# 인덱스 1부터 9까지 사용되며, 값이 1이면 해당 숫자가 이미 사용된 상태를 의미합니다.
row = [[0] * 10 for _ in range(9)]      # 9개의 행에 대해 1~9 숫자 사용 여부 (0번 인덱스는 사용하지 않음)
col = [[0] * 10 for _ in range(9)]      # 9개의 열에 대해 1~9 숫자 사용 여부
square = [[0] * 10 for _ in range(9)]   # 9개의 3x3 정사각형에 대해 1~9 숫자 사용 여부

# (x, y) 좌표가 속하는 3x3 정사각형의 번호를 계산하는 함수입니다.
def square_num(x, y):
    return (x // 3) * 3 + (y // 3)  # 행(x)을 3으로 나눈 몫에 3을 곱하고, 열(y)을 3으로 나눈 몫을 더하여 0~8 사이의 번호를 반환

# 스도쿠 판 초기 상태에서 이미 채워진 숫자들을 체크 리스트에 기록합니다.
for i in range(9):          # 0부터 8까지 행 번호 순회
    for j in range(9):      # 0부터 8까지 열 번호 순회
        if board[i][j]:     # 해당 칸에 숫자가 채워져 있다면 (0이 아니라면)
            # 해당 행, 열, 그리고 3x3 정사각형에서 해당 숫자 사용 표시를 합니다.
            row[i][board[i][j]] = 1
            col[j][board[i][j]] = 1
            square[square_num(i, j)][board[i][j]] = 1

# 깊이 우선 탐색(DFS)을 이용하여 스도쿠 판의 빈 칸을 채우는 함수입니다.
def dfs(cnt):
    # cnt가 81이면 모든 칸(0~80)을 처리한 것이므로, 현재 스도쿠 판의 해답을 출력 후 프로그램을 종료합니다.
    if cnt == 81:
        for i in range(9):
            print(*board[i])  # 각 행의 숫자들을 공백으로 구분하여 출력
        exit()  # 해답이 출력되었으므로 프로그램 종료

    # 현재 칸의 좌표 (x, y)를 계산합니다.
    x, y = cnt // 9, cnt % 9  # 0부터 80까지의 cnt를 9x9 격자 좌표로 변환

    # 현재 칸이 이미 채워져 있다면(0이 아니라면) 다음 칸으로 넘어갑니다.
    if board[x][y]:
        dfs(cnt + 1)
    else:
        # 현재 칸이 빈 칸(0)이라면 1부터 9까지의 숫자를 시도합니다.
        for i in range(1, 10):
            # 숫자 i가 해당 행, 열, 3x3 정사각형 모두에서 사용되지 않았다면
            if not row[x][i] and not col[y][i] and not square[square_num(x, y)][i]:
                # 숫자 i를 현재 칸에 넣고, 사용 표시를 업데이트합니다.
                row[x][i] = col[y][i] = square[square_num(x, y)][i] = 1
                board[x][y] = i
                dfs(cnt + 1)  # 다음 칸으로 진행하는 재귀 호출

                # 만약 재귀 호출 후 해결책을 찾지 못하면(백트래킹) 상태를 원래대로 되돌립니다.
                row[x][i] = col[y][i] = square[square_num(x, y)][i] = 0
                board[x][y] = 0

# DFS 탐색을 0번째 칸부터 시작합니다.
print(dfs(0))